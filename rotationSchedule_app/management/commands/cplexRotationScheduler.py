import cplex
import os
from django.conf import settings

os.chdir(os.path.join(os.path.dirname(os.path.abspath(settings.BASE_DIR)), 'rotationSchedule_app/management/commands'))
cpx = cplex.Cplex("rotsched.lp") ### any lp file generated by pyomo
M = 3 #numSolns to generate
ObjTolerance = 1 #fraction of best objective tolerated while finding multiple schedules,1 == find only optimal
cpx.solve() # solve for optimal solution
successful = cpx.solution.get_status()
print(successful)
#### successful != 101 := problem is infeasible .. Raise flags for the web app

if successful == 101: #101 is code for MIP_optimal #Todo: remove this hardcode
	acceptedSolnIndices = [] #indices of optimal solutions, # of such solutions = M
	alternate_solutions = {} #not used currently
	obj_value = {} #objective value of each solution
	solnIndicesAll = [] # indices of all solutions found so far
	solnNamesAll = [] # names of all solutions found so far


	bestObjective = cpx.solution.get_objective_value()
	print(bestObjective)
	optimal_solution = cpx.solution.get_values() ## One optimal solution ready to be displayed in the web-app
	
	
	cpx.parameters.mip.pool.intensity.set(4) #leave no stone unturned: find all feasible solutions
	numOptimalSolns = M
	cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
	cpx.populate_solution_pool() #solve and populate the solution pool
	#numSolns = cpx.solution.pool.get_num() ##get the number of solutions generated.
	solnNames = cpx.solution.pool.get_names()
	solnIndices = cpx.solution.pool.get_indices(solnNames)
	print(solnNames)
	while len(acceptedSolnIndices) < numOptimalSolns and solnIndices:
		for i in solnIndices:
			obj_value[i] = cpx.solution.pool.get_objective_value(i)
			if obj_value[i] >= ObjTolerance*bestObjective:
				acceptedSolnIndices.append(i)
				if len(acceptedSolnIndices) >= numOptimalSolns: 
					break
		solnIndicesAll.extend(solnIndices)
		solnNamesAll.extend(solnNames)

		cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
		cpx.populate_solution_pool() #solve and populate the solution pool
		#numSolns = cpx.solution.pool.get_num() ##get the number of solutions generated.
		solnNames = cpx.solution.pool.get_names()
		[solnNames.remove(s) for s in solnNamesAll] #getting rid of solutions that have been found already
		solnIndices = cpx.solution.pool.get_indices(solnNames)
	print(acceptedSolnIndices)
	print(solnIndicesAll)
	print(obj_value)

#	if len(acceptedSolnIndices) < numOptimalSolns:
		##pick M best solns from solnIndicesAll
		
# 
# ###Since we set this to 10, numSolns =10
# solnNames = cpx.solution.pool.get_names() ##names of the solutions
# print(solnNames)
# solnIndices = cpx.solution.pool.get_indices(solnNames) ## indices of all solutions from their names
# cpx.populate_solution_pool()
# solnNames2 = cpx.solution.pool.get_names() ##names of the solutions
# print(solnNames2)
# #####Find the top three (or N) solutions from the solution pool based on their objective value 
# for i in solnIndices:
# 	print(cpx.solution.pool.get_objective_value(i))
# ####Todo:find and compare with the best solution in the solution pool to find top N
# 
# #cpx.solution.pool.get_values(solnIndices[0]) # get values for solution 1, returns values of all variables as a list
# #cpx.solution.pool.get_values(solnIndices[1]) #get values for solution 2
# #cpx.solution.pool.write("ind.sol",solnIndices[0]) ##write only 1st solution to a .sol file
# #cpx.solution.pool.get_values(solnIndices[0],"Z(1_Rotation1_1)")