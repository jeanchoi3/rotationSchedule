from optparse import make_option
from django.core.management.base import BaseCommand, CommandError
from rotationSchedule_app.models import Block, Resident, Year, Track, Program, Rotation, Event, Schedule, Template, TemplateEvent
import copy
import random
import operator
import sys
#import numpy as np
import logging
import os
from django.conf import settings
import datetime
from dateutil.rrule import rrule, WEEKLY

logging.basicConfig(stream=sys.stdout, format='%(message)s',level=logging.INFO)

class Command(BaseCommand):
	args = '<event_pk event_start event_end>'
	option_list = BaseCommand.option_list + (
    	make_option('--long', '-l', dest='long',
    		help='Help for the long options'),
    	)
	help = 'Help text goes here'
	
	def handle(self, *args, **options):
		import cplex
		import os
		from django.conf import settings

		os.chdir(os.path.join(os.path.dirname(os.path.abspath(settings.BASE_DIR)), 'rotationSchedule_app/management/commands'))
		cpx = cplex.Cplex("rotsched.lp") ### any lp file generated by pyomo
		M = 3 #numSolns to generate
		ObjTolerance = 1 #fraction of best objective tolerated while finding multiple schedules,1 == find only optimal
		cpx.solve() # solve for optimal solution
		successful = cpx.solution.get_status()
		print(successful)
		#### successful != 101 := problem is infeasible .. Raise flags for the web app

		if successful == 101: #101 is code for MIP_optimal #Todo: remove this hardcode
			acceptedSolnIndices = [] #indices of optimal solutions, # of such solutions = M
			acceptedSolnVars = [] #list of lists of Z variables of accepted solns (as strings)
								  # used for comparison with newly found schedules to prevent redundancy
			alternate_solutions = {} #not used currently
			obj_value = {} #objective value of each solution
			solnIndicesAll = [] # indices of all solutions found so far
			solnNamesAll = [] # names of all solutions found so far


			bestObjective = cpx.solution.get_objective_value()
			print(bestObjective)
			optimal_solution = cpx.solution.get_values() ## One optimal solution ready to be displayed in the web-app
			
			
			cpx.parameters.mip.pool.intensity.set(4) #leave no stone unturned: find all feasible solutions
			numOptimalSolns = M
			cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
			cpx.populate_solution_pool() #solve and populate the solution pool
			#numSolns = cpx.solution.pool.get_num() ##get the number of solutions generated.
			solnNames = cpx.solution.pool.get_names()
			solnIndices = cpx.solution.pool.get_indices(solnNames)
			print(solnNames)
			while len(acceptedSolnIndices) < numOptimalSolns and solnIndices:
				for i in solnIndices:
					solnVars = [] #list of Z variables of this solution
								  # used for comparison with previously-found solns to prevent redundancy
					obj_value[i] = cpx.solution.pool.get_objective_value(i)

					# solution objective value is above threshold
					if obj_value[i] >= ObjTolerance*bestObjective:
						#add all Z variables to solnVars, then compare with previously-found solns; check uniqueness
						for res_pk in resident_pk_to_index:
							for rotation in rotation_names:
								for week in weeks: 
									#print "Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation)+"_"+str(week)+")"
									if str(cpx.solution.pool.get_values(solnIndices[i],"Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation)+"_"+str(week)+")")) == "1.0":
										solnVars.append("Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation)+"_"+str(week)+")")

						unique_schedule = True
						for sched in acceptedSolnVars:
							if set(sched) == set(solnVars):
								unique_schedule = False
								break
						if unique_schedule:
							acceptedSolnVars.append(solnVars)

							#create model Schedule instance
							createdSchedule = Schedule(name="Schedule"+str(i+1),utility=obj_value[i])
							createdSchedule.save()
							print createdSchedule.name

							#create model Events for this schedule
							for assignment in sched:
								split_variable = assignment.strip(")").split("(")[1].split("_")
								res = Resident.objects.filter(pk=resident_index_to_pk[int(split_variable[0])])[0]
								rot = Rotation.objects.filter(name=split_variable[1])[0]
								start = week_to_date[int(split_variable[2])]
								end = week_to_end_date[int(split_variable[2])]
								createdEvent = Event(resident=res,rotation=rot,startDate=start,endDate=end,schedule=createdSchedule)
								createdEvent.save()

							acceptedSolnIndices.append(i)
							if len(acceptedSolnIndices) >= numOptimalSolns: 
								break
				solnIndicesAll.extend(solnIndices)
				solnNamesAll.extend(solnNames)

				cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
				cpx.populate_solution_pool() #solve and populate the solution pool
				#numSolns = cpx.solution.pool.get_num() ##get the number of solutions generated.
				solnNames = cpx.solution.pool.get_names()
				[solnNames.remove(s) for s in solnNamesAll] #getting rid of solutions that have been found already
				solnIndices = cpx.solution.pool.get_indices(solnNames)
			print(acceptedSolnIndices)
			print(solnIndicesAll)
			print(obj_value)

		#	if len(acceptedSolnIndices) < numOptimalSolns:
				##pick M best solns from solnIndicesAll
				
		# 
		# ###Since we set this to 10, numSolns =10
		# solnNames = cpx.solution.pool.get_names() ##names of the solutions
		# print(solnNames)
		# solnIndices = cpx.solution.pool.get_indices(solnNames) ## indices of all solutions from their names
		# cpx.populate_solution_pool()
		# solnNames2 = cpx.solution.pool.get_names() ##names of the solutions
		# print(solnNames2)
		# #####Find the top three (or N) solutions from the solution pool based on their objective value 
		# for i in solnIndices:
		# 	print(cpx.solution.pool.get_objective_value(i))
		# ####Todo:find and compare with the best solution in the solution pool to find top N
		# 
		# #cpx.solution.pool.get_values(solnIndices[0]) # get values for solution 1, returns values of all variables as a list
		# #cpx.solution.pool.get_values(solnIndices[1]) #get values for solution 2
		# #cpx.solution.pool.write("ind.sol",solnIndices[0]) ##write only 1st solution to a .sol file
		# #cpx.solution.pool.get_values(solnIndices[0],"Z(1_Rotation1_1)")