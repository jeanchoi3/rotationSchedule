import cplex
cpx = cplex.Cplex("8block.lp") ### any lp file generated by pyomo
M = 3 #numSolns to generate
ObjTolerance = 0.50 #fraction of best objective tolerated while finding multiple schedules,1 == find only optimal
cpx.parameters.preprocessing.symmetry.set(5)

cpx.solve() # solve for optimal solution
cpx.write('myfile.sol')
print cpx.solution.get_objective_value()
successful = cpx.solution.get_status()
print(successful)

		### successful != 101 := problem is infeasible .. Raise flags for the web app

		# if successful == 101 or successful == 102: #101 is code for MIP_optimal #Todo: remove this hardcode
		# 	acceptedSolnIndices = [] #indices of optimal solutions, not including best optimal, # of such solutions = M
		# 	acceptedSolnVars = [] #list of lists of Z variables of accepted solns (as strings), including best optimal
		# 						  # used for comparison with newly found schedules to prevent redundancy
		# 	alternate_solutions = {} #not used currently
		# 	obj_value = {} #objective value of each solution
		# 	solnIndicesAll = [] # indices of all solutions found so far, not including best optimal
		# 	solnNamesAll = [] # names of all solutions found so far, not including best optimal


		# 	bestObjective = cpx.solution.get_objective_value()
			#optimal_solution = cpx.solution.get_values() ## One optimal solution ready to be displayed in the web-app
			#optimal_solution_1 = cpx.solution.pool.get_values(0, "Z(45_MICU_N_1)")
			#print "Optimal solution 1: "+str(optimal_solution_1)+"---------------------------------"
			##print "Variables: "+str(cpx.variables.get_names())

			# createdSchedule = Schedule(name="Best Solution",utility=bestObjective)
			# createdSchedule.save()

			# solnVars = [] #list of Z variables of this solution
			# 			  # used for comparison with previously-found solns to prevent redundancy
			# #create events in best schedule
			# for res_pk in resident_pk_to_index:
			# 	for rotation in rotation_names:
			# 		for week in weeks:
			# 			#print "Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")"
			# 			if str(cpx.solution.pool.get_values(0,"Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")")) == "1.0":
			# 				solnVars.append("Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")") #note: keep rotation as is, so later event can refer to original rotation name, w/o "_" replacements
			# 				res = Resident.objects.filter(pk=res_pk)[0]
			# 				rot = Rotation.objects.filter(name=rotation)[0]
			# 				start = week_to_date[week]
			# 				end = week_to_end_date[week]
			# 				createdEvent = Event(resident=res,rotation=rot,startDate=start,endDate=end,schedule=createdSchedule)
			# 				createdEvent.save()

			# acceptedSolnVars.append(solnVars) #add best optimal solution to accepted soln variable list, to prevent redundancy in solution pool


			# cpx.parameters.mip.pool.intensity.set(4) #leave no stone unturned: find all feasible solutions
			# numOptimalSolns = M
			# cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
			# cpx.populate_solution_pool() #solve and populate the solution pool
			# solnNames = cpx.solution.pool.get_names()
			# solnIndices = cpx.solution.pool.get_indices(solnNames)

			# while (len(acceptedSolnIndices)+1) < numOptimalSolns and solnIndices:
			# 	for i in solnIndices:
			# 		solnVars = [] #list of Z variables of this solution
			# 					  # used for comparison with previously-found solns to prevent redundancy
			# 		obj_value[i] = cpx.solution.pool.get_objective_value(i)

			# 		# solution objective value is above threshold
			# 		if obj_value[i] >= ObjTolerance*bestObjective:
			# 			#add all Z variables to solnVars, then compare with previously-found solns; check uniqueness
			# 			for res_pk in resident_pk_to_index:
			# 				for rotation in rotation_names:
			# 					for week in weeks: 
			# 						#print "Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation)+"_"+str(week)+")"
			# 						#print "Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")"
			# 						if str(cpx.solution.pool.get_values(i,"Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")")) == "1.0": #used to have solnIndices[i] as first arg!!!
			# 							solnVars.append("Z("+str(resident_pk_to_index[res_pk])+"_"+str(rotation_name_to_index[rotation])+"_"+str(week)+")")

			# 						#rotation.replace("-","_").replace(" ","_")
			# 			unique_schedule = True

			# 			#compare this schedule to every already-accepted soln
			# 			for sched in acceptedSolnVars:
			# 				if set(sched) == set(solnVars):
			# 					unique_schedule = False
			# 					break
			# 			if unique_schedule:
			# 				acceptedSolnVars.append(solnVars)

			# 				#create model Schedule instance
			# 				createdSchedule = Schedule(name="Schedule"+str(i),utility=obj_value[i])
			# 				createdSchedule.save()
			# 				#print createdSchedule.name

			# 				#create model Events for this schedule
			# 				for assignment in solnVars:
			# 					split_variable = assignment.strip(")").split("(")[1].split("_")
			# 					#print split_variable
			# 					res = Resident.objects.filter(pk=resident_index_to_pk[int(split_variable[0])])[0]
			# 					rot = Rotation.objects.filter(name=rotation_index_to_name[int(split_variable[1])])[0]
			# 					start = week_to_date[int(split_variable[2])]
			# 					end = week_to_end_date[int(split_variable[2])]
			# 					createdEvent = Event(resident=res,rotation=rot,startDate=start,endDate=end,schedule=createdSchedule)
			# 					createdEvent.save()

			# 				acceptedSolnIndices.append(i)

			# 	solnIndicesAll.extend(solnIndices)
			# 	solnNamesAll.extend(solnNames)

			# 	cpx.parameters.mip.limits.populate.set(M) #set number of solutions to M
			# 	cpx.populate_solution_pool() #solve and populate the solution pool
			# 	solnNames = cpx.solution.pool.get_names()
			# 	[solnNames.remove(s) for s in solnNamesAll] #getting rid of solutions that have been found already
			# 	solnIndices = cpx.solution.pool.get_indices(solnNames)

			# print "Accepted solution indices, not including best solution: "+str(acceptedSolnIndices)
			# print "All solution indices: "+str(solnIndicesAll)
			# print(obj_value)
